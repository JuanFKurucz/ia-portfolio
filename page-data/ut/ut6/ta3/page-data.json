{"componentChunkName":"component---src-templates-post-jsx","path":"/ut/ut6/ta3","result":{"data":{"markdownRemark":{"html":"<p>En este artículo se evaluarán los operadores de RandomForest y AdaBoost en RapidMiner</p>\n<h1>Datos</h1>\n<p>Para esta prueba utilizaremos el siguiente conjunto de datos:</p>\n<ul>\n<li><a href=\"https://github.com/JuanFKurucz/ia-portfolio/blob/main/content/posts/ut/ut6/ta/ta3/chronic_kidney_disease_full.arff?raw=true\">chronic<em>kidney</em>disease_full.arff</a></li>\n<li><a href=\"https://github.com/JuanFKurucz/ia-portfolio/blob/main/content/posts/ut/ut6/ta/ta3/chronic_kidney_disease.arff?raw=true\">chronic<em>kidney</em>disease.arff</a></li>\n<li><a href=\"https://github.com/JuanFKurucz/ia-portfolio/blob/main/content/posts/ut/ut6/ta/ta3/chronic_kidney_disease.info.txt?raw=true\">chronic<em>kidney</em>disease.info.txt</a></li>\n</ul>\n<h1>Pipeline</h1>\n<p>Se usará el siguiente pipeline en RapidMiner:\n<img src=\"https://github.com/JuanFKurucz/ia-portfolio/blob/main/content/posts/ut/ut6/ta/ta3/pipeline.png?raw=true\" alt=\"pipeline\"></p>\n<p>En el cual tenemos 2 flujos\n<img src=\"https://github.com/JuanFKurucz/ia-portfolio/blob/main/content/posts/ut/ut6/ta/ta3/cross1.png?raw=true\" alt=\"cross1\">\n<img src=\"https://github.com/JuanFKurucz/ia-portfolio/blob/main/content/posts/ut/ut6/ta/ta3/cross2.png?raw=true\" alt=\"cross2\"></p>\n<h2>Random Forest</h2>\n<p>RandomForest es un algoritmo que produce \"un bosque aleatorio\", esto se hace en base a construir un cierto número de árboles de decisión, estos árboles son creados dados ciertos parámetros tomando decisiones aleatorias. Por ende, RandomForest termina siendo un bosque ya que contiene múltiples árboles diferentes creados aleatoriamente para resolver la problemática.</p>\n<h2>AdaBoost</h2>\n<p>Adaptive Boosting es un algoritmo que genera una conjunción de clasificadores para incrementar su performance en base a ir mejorando los resultados de predicción de algoritmos previos.</p>\n<h1>Resultados</h1>\n<p>A continuación podemos ver los resultados de performance</p>\n<h2>Random Forest</h2>\n<p>Los resultados del ensamble de Random Forest fueron:\n<img src=\"https://github.com/JuanFKurucz/ia-portfolio/blob/main/content/posts/ut/ut6/ta/ta3/performance_randomforest.png?raw=true\" alt=\"performance_randomforest\"></p>\n<h2>AdaBoost</h2>\n<p>Los resultados del modelo de AdaBoost fueron:\n<img src=\"https://github.com/JuanFKurucz/ia-portfolio/blob/main/content/posts/ut/ut6/ta/ta3/performance_adaboost.png?raw=true\" alt=\"performance_adaboost\"></p>\n<h1>Archivos</h1>\n<ul>\n<li><a href=\"https://github.com/JuanFKurucz/ia-portfolio/blob/main/content/posts/ut/ut6/ta/ta3/ut6ta3.rmp\">Archivo de RapidMiner</a></li>\n</ul>","frontmatter":{"date":"2021-11-19","title":"Usando Random Forest y AdaBoost en RapidMiner","tags":["Ensambles","Random Forest","RapidMiner","Cross Validation","Performance","AdaBoost","Chronic kidney disease Dataset"],"cover":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAAEVC61tAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACDklEQVQoz2VT227TUBD0P4MobRPHdnypUFElKoIS4iTNxQl/0xd4gBSiqk3r5uJc6eMwu8cJpDysfLy7Z3Z2do9VrD/Bu8rgteawwmSNk/OfCJMNLK9FbzuDFQ228OKxCbuNDG71Hn77EdGAaSeVe01TE6CrGa/0N4iSLYLuCk7tB4LeQnDoFKxmhuKn75AkK+itcPZlC7c106DbnOGM36CzoG+qZzEWXyFicuFCbhqnIAbJgqWWelkRhaXW31me6LXGcONfetbEV+9vYNcnh+z3XYgkU1LITDfl9sKgURoJSnmn8ZTTyDkKtNOYQygE3SXKtQkDvxG1h/A7S8pAXzeXtPRxBKdqVNx16XenihayUeW400zMb85xfH7L8zPsyjWTVyqwjmHX1b8XpLQbf4NKNzAxy44nOLq8hczNaUzVSmL0l/L//30z2oRqpSjUUti1OxQ+3+G4msIqc1I6iO4aby5GeP1uCCfOdKo+xZCFekvaMvaIjLz6GMXLaxS4Aj5FCvsUiwyFpfybSUsLFOG0MsbRhxECSh4m24P2jHAEbHED469w6jcIcuEUuLdWffaAstZ+M0VEk/EIYMgEmy2VuAhyQfLKfAt27QF2nBpmBJTR7bbJrNhgc7hmfTNGYeDVH+DHZg+EoT6WzlCfQrlNIPr3GIPNC8DcuT+/KGI64TJxkaJkvV/8v/EN/gBv6+LyZCBQ3gAAAABJRU5ErkJggg==","aspectRatio":1.6901408450704225,"src":"/static/59b84512c97be69b156cd5fb8a9f4743/1de8a/pipeline.png","srcSet":"/static/59b84512c97be69b156cd5fb8a9f4743/0d3b3/pipeline.png 480w,\n/static/59b84512c97be69b156cd5fb8a9f4743/263b6/pipeline.png 960w,\n/static/59b84512c97be69b156cd5fb8a9f4743/1de8a/pipeline.png 1702w","srcWebp":"/static/59b84512c97be69b156cd5fb8a9f4743/17412/pipeline.webp","srcSetWebp":"/static/59b84512c97be69b156cd5fb8a9f4743/83f4f/pipeline.webp 480w,\n/static/59b84512c97be69b156cd5fb8a9f4743/ce114/pipeline.webp 960w,\n/static/59b84512c97be69b156cd5fb8a9f4743/17412/pipeline.webp 1702w","sizes":"(max-width: 1702px) 100vw, 1702px"},"resize":{"src":"/static/59b84512c97be69b156cd5fb8a9f4743/73f08/pipeline.png"}}}}}},"pageContext":{"pathSlug":"/ut/ut6/ta3","prev":{"frontmatter":{"path":"/ut/ut6/ta1","title":"Evaluando operadores de ensamble en RapidMiner","tags":["Ensambles","Naive Bayes","RapidMiner","Validación","Performance","Vote","KNN","Árbol de decisión","Iris Dataset","Bagging"]}},"next":{"frontmatter":{"path":"/ut/ut7/ta1","title":"Métricas y evaluación de modelos en clasificación","tags":["Ajuste, evaluación y sintonía de modelos","RapidMiner","Accuracy","False Positive","False Negative","True Positive","True Negative","Sensitivity","Specificity","AUC","ROC","Validacion","Lift Chart","Matriz de confusion","Precision","Recall"]}}}},"staticQueryHashes":["1830426702"]}